---
title: 汇编语言期末
tags:
  - 技能积累
categories:
  - 技能积累
date: 2025-06-06 21:21:33
---

 ## 1 汇编语言基础

### 计算机的硬件组成结构

![image-20250606212224973](_汇编语言期末/image-20250606212224973.png)

这样抽象是因为程序员写程序时不需要管具体内部逻辑，比如MOV EAX,10只需要知道寄存器叫EAX和如何使用就行了。

### IA-32的三种存储模型

![image-20250606212353181](_汇编语言期末/image-20250606212353181.png)

![image-20250606212501046](_汇编语言期末/image-20250606212501046.png)

![image-20250606212519798](_汇编语言期末/image-20250606212519798.png)

![image-20250606212619856](_汇编语言期末/image-20250606212619856.png)

### 处理器寄存器

![image-20250606212655962](_汇编语言期末/image-20250606212655962.png)

![image-20250606213222896](_汇编语言期末/image-20250606213222896.png)![image-20250606213429772](_汇编语言期末/image-20250606213429772.png)![image-20250606213444072](_汇编语言期末/image-20250606213444072.png)![image-20250606213459167](_汇编语言期末/image-20250606213459167.png)

### 处理器指令格式

![image-20250606214305844](_汇编语言期末/image-20250606214305844.png)

![](_汇编语言期末/image-20250606214431126.png)这是什么玩意

### 汇编语言语句格式

![image-20250606215034536](_汇编语言期末/image-20250606215034536.png)![image-20250606215052641](_汇编语言期末/image-20250606215052641.png)

### 源程序框架

![image-20250606215308790](_汇编语言期末/image-20250606215308790.png)![image-20250606215608047](_汇编语言期末/image-20250606215608047.png)

![image-20250606215724791](_汇编语言期末/image-20250606215724791.png)![image-20250606215750288](_汇编语言期末/image-20250606215750288.png)![image-20250606215831817](_汇编语言期末/image-20250606215831817.png)

### 信息显示程序

![image-20250607093141246](_汇编语言期末/image-20250607093141246.png)![image-20250607093151979](_汇编语言期末/image-20250607093151979.png)

![image-20250607093111425](_汇编语言期末/image-20250607093111425.png)

![image-20250607093208129](_汇编语言期末/image-20250607093208129.png)

### MASM开发软件

### 源程序开发过程

![image-20250607093546789](_汇编语言期末/image-20250607093546789.png)![image-20250607093614757](_汇编语言期末/image-20250607093614757.png)![image-20250607093640624](_汇编语言期末/image-20250607093640624.png)

## 2 数据表示和寻址

### 问题|知识点

这三个到底是什么关系

![image-20250607150936035](_汇编语言期末/image-20250607150936035.png)

### 整数编码

![image-20250607103934286](_汇编语言期末/image-20250607103934286.png)

![image-20250607103929216](_汇编语言期末/image-20250607103929216.png)

### 字符编码

![image-20250607095149176](_汇编语言期末/image-20250607095149176.png)![image-20250607095206628](_汇编语言期末/image-20250607095206628.png)

### 汇编语言的常量表达

![image-20250607095323868](_汇编语言期末/image-20250607095323868.png)

### 数据表达程序

![image-20250607100346047](_汇编语言期末/image-20250607100346047.png)![image-20250607100447375](_汇编语言期末/image-20250607100447375.png)![image-20250607100522328](_汇编语言期末/image-20250607100522328.png)![image-20250607100545922](_汇编语言期末/image-20250607100545922.png)![image-20250607100728151](_汇编语言期末/image-20250607100728151.png)![image-20250607101102022](_汇编语言期末/image-20250607101102022.png)	![image-20250607101145652](_汇编语言期末/image-20250607101145652.png)

### 汇编语言中的变量定义

![image-20250607101842228](_汇编语言期末/image-20250607101842228.png)

![image-20250607101748816](_汇编语言期末/image-20250607101748816.png)

### 8位变量定义

![image-20250607102349181](_汇编语言期末/image-20250607102349181.png)

**变量的符号性（signed/unsigned）不由定义时的存储空间决定，而由后续的操作指令解释**。

所以不区分是否是有无符号数。

### 16位变量定义

![image-20250607104044457](_汇编语言期末/image-20250607104044457.png)![image-20250607104108737](_汇编语言期末/image-20250607104108737.png)

### 32位变量定义

![image-20250607104204145](_汇编语言期末/image-20250607104204145.png)

### 多字节数据的存储顺序

![image-20250607104308212](_汇编语言期末/image-20250607104308212.png)![image-20250607104324694](_汇编语言期末/image-20250607104324694.png)![image-20250607104340043](_汇编语言期末/image-20250607104340043.png)

### 变量的定位

  ![image-20250607110314713](_汇编语言期末/image-20250607110314713.png)![image-20250607110419961](_汇编语言期末/image-20250607110419961.png)![image-20250607110431600](_汇编语言期末/image-20250607110431600.png)

### 变量的地址属性

![image-20250607110504846](_汇编语言期末/image-20250607110504846.png)![image-20250607110544439](_汇编语言期末/image-20250607110544439.png)![image-20250607110641816](_汇编语言期末/image-20250607110641816.png)![image-20250607110737036](_汇编语言期末/image-20250607110737036.png)![image-20250607110842234](_汇编语言期末/image-20250607110842234.png)

![image-20250607110916624](_汇编语言期末/image-20250607110916624.png)![image-20250607110927113](_汇编语言期末/image-20250607110927113.png)![image-20250607110948488](_汇编语言期末/image-20250607110948488.png)![image-20250607111053732](_汇编语言期末/image-20250607111053732.png)![image-20250607111138768](_汇编语言期末/image-20250607111138768.png)![image-20250607111157847](_汇编语言期末/image-20250607111157847.png)

### 变量的类型属性

![image-20250607111413484](_汇编语言期末/image-20250607111413484.png)

![image-20250607111636092](_汇编语言期末/image-20250607111636092.png)

![image-20250607111654799](_汇编语言期末/image-20250607111654799.png)

![image-20250607111725695](_汇编语言期末/image-20250607111725695.png)![image-20250607111756795](_汇编语言期末/image-20250607111756795.png)

![image-20250607111813133](_汇编语言期末/image-20250607111813133.png)

### 寻址方式

![image-20250607111903575](_汇编语言期末/image-20250607111903575.png)

![image-20250607112002786](_汇编语言期末/image-20250607112002786.png)

### 立即数寻址

![image-20250607114250801](_汇编语言期末/image-20250607114250801.png)![image-20250607114302422](_汇编语言期末/image-20250607114302422.png)

标号的偏移地址是什么

![image-20250607114531350](_汇编语言期末/image-20250607114531350.png)

### 寄存器寻址

![image-20250607114612111](_汇编语言期末/image-20250607114612111.png)

### 存储器寻址

偏移地址就是有效地址吗

好像偏移地址是形式地址，寻址方式+形式地址=有效地址（EA）

![image-20250607114830156](_汇编语言期末/image-20250607114830156.png)

![image-20250607114841056](_汇编语言期末/image-20250607114841056.png)

![image-20250607114712242](_汇编语言期末/image-20250607114712242.png)

![image-20250607114743492](_汇编语言期末/image-20250607114743492.png)

![image-20250607114904249](_汇编语言期末/image-20250607114904249.png)![image-20250607114910703](_汇编语言期末/image-20250607114910703.png)![image-20250607114918785](_汇编语言期末/image-20250607114918785.png)![image-20250607114939843](_汇编语言期末/image-20250607114939843.png)![image-20250607114959151](_汇编语言期末/image-20250607114959151.png)

### 存储器的直接寻址

![image-20250607115143493](_汇编语言期末/image-20250607115143493.png)

![image-20250607153712587](_汇编语言期末/image-20250607153712587.png)

![image-20250607115224600](_汇编语言期末/image-20250607115224600.png)

![image-20250607151257262](_汇编语言期末/image-20250607151257262.png)

![image-20250607151354649](_汇编语言期末/image-20250607151354649.png)

![image-20250607151422220](_汇编语言期末/image-20250607151422220.png)

![image-20250607151535029](_汇编语言期末/image-20250607151535029.png)![image-20250607151539357](_汇编语言期末/image-20250607151539357.png)

![image-20250607151626785](_汇编语言期末/image-20250607151626785.png)

![image-20250607151959620](_汇编语言期末/image-20250607151959620.png)

### 存储器的寄存器间接寻址

![image-20250607152225676](_汇编语言期末/image-20250607152225676.png)

![image-20250607153731992](_汇编语言期末/image-20250607153731992.png)

![image-20250607152250067](_汇编语言期末/image-20250607152250067.png)

![image-20250607152608809](_汇编语言期末/image-20250607152608809.png)

![image-20250607152650787](_汇编语言期末/image-20250607152650787.png)

### 存储器的寄存器相对寻址

![image-20250607152735603](_汇编语言期末/image-20250607152735603.png)

![image-20250608154630358](_汇编语言期末/image-20250608154630358.png)

![image-20250607153014195](_汇编语言期末/image-20250607153014195.png)

![image-20250607153058567](_汇编语言期末/image-20250607153058567.png)

### 存储器的变址寻址

![image-20250607153129455](_汇编语言期末/image-20250607153129455.png)

![image-20250607153237799](_汇编语言期末/image-20250607153237799.png)

![image-20250607153242969](_汇编语言期末/image-20250607153242969.png)

![image-20250607153334282](_汇编语言期末/image-20250607153334282.png)

![image-20250607153400738](_汇编语言期末/image-20250607153400738.png)

![image-20250607153548649](_汇编语言期末/image-20250607153548649.png)

![image-20250607153607757](_汇编语言期末/image-20250607153607757.png)

## 3 通用数据处理指令

### 问题

这个为什么有类型了？

![image-20250607154605870](_汇编语言期末/image-20250607154605870.png)

### MOV（数据传送指令）

![image-20250607155244164](_汇编语言期末/image-20250607155244164.png)

![image-20250607154238695](_汇编语言期末/image-20250607154238695.png)

### 常见语法错误

![image-20250607154321903](_汇编语言期末/image-20250607154321903.png)

![image-20250607154407188](_汇编语言期末/image-20250607154407188.png)

![image-20250607154445878](_汇编语言期末/image-20250607154445878.png)

![image-20250607154605870](_汇编语言期末/image-20250607154605870.png)

![image-20250607154631735](_汇编语言期末/image-20250607154631735.png)

### XCHG（交换指令）

![image-20250607155657823](_汇编语言期末/image-20250607155657823.png)

### LEA（地址传送指令）

![image-20250607163338995](_汇编语言期末/image-20250607163338995.png)

![image-20250607163345007](_汇编语言期末/image-20250607163345007.png)![image-20250607163356383](_汇编语言期末/image-20250607163356383.png)

![image-20250607163416468](_汇编语言期末/image-20250607163416468.png)

### 堆栈

![image-20250607163955504](_汇编语言期末/image-20250607163955504.png)

### PUSH和POP指令

注意堆栈向下生长和小端模式。

![image-20250607164152140](_汇编语言期末/image-20250607164152140.png)

![image-20250607164228086](_汇编语言期末/image-20250607164228086.png)

![image-20250607164501793](_汇编语言期末/image-20250607164501793.png)

### 零标志、符号标志和奇偶标志

进位标志CF（Carry Flag）

溢出标志OF（Overflow Flag）

![image-20250607165419098](_汇编语言期末/image-20250607165419098.png)

![image-20250607164646391](_汇编语言期末/image-20250607164646391.png)

![image-20250607164907464](_汇编语言期末/image-20250607164907464.png)![image-20250607164912653](_汇编语言期末/image-20250607164912653.png)![image-20250607170349266](_汇编语言期末/image-20250607170349266.png)

![image-20250607164858565](_汇编语言期末/image-20250607164858565.png)

![image-20250607165100152](_汇编语言期末/image-20250607165100152.png)

### ADD指令

![image-20250607170028546](_汇编语言期末/image-20250607170028546.png)

![image-20250607170038114](_汇编语言期末/image-20250607170038114.png)

![image-20250607170144250](_汇编语言期末/image-20250607170144250.png)



### SUB指令

## 4 程序结构（看一下多重循环）

### 自然数求和程序





## 8 DOS环境程序设计

## 知识点|杂项

- 多个操作数的IMUL，乘积不倍长。（CF=OF=1）表示溢出，不倍长要注意溢出。
- 感觉可多有符号数和无符号数的运算结果都是相同的。
- ==这个符号扩展指令感觉有点用，MOVZX，MOVSX，这个MOVZX EAX,bx的时候就不用清空ebx的高16位了，直接符号扩展MOV就行了。还有就是MOVZX EAX,bvar也可以==
- 除了NOT指令不影响标志外，其他逻辑标志都会使OF=CF=0。
- 感觉可多都是给了两个存储器的数，这时运算就应该先把一个放到寄存器里面，然后和另外一个运算
- 记得移位指令中是有一个CF的，所以所有的左移和右移都会影响到CF
- ![image-20250624200529030](_汇编语言期末/image-20250624200529030.png)移位操作的源操作数好像只能是8位立即数或者CL，不过好像确实一次也移动不了几位。只不过移位的时候记得不要用存储器数，要放到CL中
- dispuid这几个的入口参数好像都是EAX这个数而不是地址
- 注意ROR和RCR的本质区别，一个CF只被影响没有参与进来，一个也参加循环了，循环移位感觉和有无符号数没太大关系，就是为了特殊用途，只有算术移位和逻辑移位才会在意这个。![image-20250624201027401](_汇编语言期末/image-20250624201027401.png)
- READMSG并不是读入字符串将字符串存到EAX中，而是将他的字符个数存进去
- PUSH不支持字节操作，要么是字操作（2）或者双字（4）
- 32位保护方式使用平展存储模型，不允许应用程序进行段间转移
- 那个奇校验程序直接用PF标志就行了
- 要时刻注意+1是加一个字节而不是一个元素，如dword就应该是+4
- 对于字符串可以用break
- FFH也是可以自定义的标识符
- 记好0和'0'的区别，0想要输出，必须先加30H
- 堆栈在过程调用中为传递参数，返回地址，局部变量和保护寄存器所保留的空间，叫做==堆栈帧==



![image-20250624195857700](_汇编语言期末/image-20250624195857700.png)

### 第1章

- 从应用角度看，汇编语言程序员可以将计算机抽象为：寄存器、存储器地址、输入输出地址
- ![image-20250620161747857](_汇编语言期末/image-20250620161747857.png)

![image-20250620162727978](_汇编语言期末/image-20250620162727978.png)![image-20250620162745047](_汇编语言期末/image-20250620162745047.png)



![image-20250620163749703](_汇编语言期末/image-20250620163749703.png)

![image-20250620163827935](_汇编语言期末/image-20250620163827935.png)

![img](_汇编语言期末/68e8b3658566bbe7fd40146d8b76bed3.png)

![image-20250620172450206](_汇编语言期末/image-20250620172450206.png)![image-20250620172805468](_汇编语言期末/image-20250620172805468.png)![image-20250620172833926](_汇编语言期末/image-20250620172833926.png)![image-20250620172846969](_汇编语言期末/image-20250620172846969.png)

![image-20250620172945388](_汇编语言期末/image-20250620172945388.png)

### 第2章

![image-20250620173835165](_汇编语言期末/image-20250620173835165.png)

![image-20250620174337927](_汇编语言期末/image-20250620174337927.png)

![image-20250620182850033](_汇编语言期末/image-20250620182850033.png)![image-20250620183039248](_汇编语言期末/image-20250620183039248.png)![image-20250620183346306](_汇编语言期末/image-20250620183346306.png)

![image-20250620183517459](_汇编语言期末/image-20250620183517459.png)

![image-20250620184648416](_汇编语言期末/image-20250620184648416.png)

![image-20250620185254644](_汇编语言期末/image-20250620185254644.png)![image-20250620190236811](_汇编语言期末/image-20250620190236811.png)


![image-20250620193231476](_汇编语言期末/image-20250620193231476.png)![image-20250620193118382](_汇编语言期末/image-20250620193118382.png)

![image-20250620193756488](_汇编语言期末/image-20250620193756488.png)

![image-20250620193915641](_汇编语言期末/image-20250620193915641.png)

这种就是10个数据项。![image-20250620194117005](_汇编语言期末/image-20250620194117005.png)

![image-20250620200658400](_汇编语言期末/image-20250620200658400.png)

![image-20250620201044767](_汇编语言期末/image-20250620201044767.png)

![image-20250620233235015](_汇编语言期末/image-20250620233235015.png)

我的理解就是所有数据的访问基本都是通过地址的（除了立即数），立即数之所以不被识别为地址是因为他没有加中括号。就比如寄存器间接寻址就是[eax]，这种因为存的是便宜地址，所以需要加中括号。

![image-20250620234310727](_汇编语言期末/image-20250620234310727.png)==好像 MOV var,10;是对的，因为变量有类型，但是间接寻址就没有类型了，所以需要加ptr。==

![image-20250620234805407](_汇编语言期末/image-20250620234805407.png)

![image-20250620235029493](_汇编语言期末/image-20250620235029493.png)

这个还是寄存器里面存的地址，只不过是计算过后得来的。

==如果那个位移量是变量名的话，那么就有变量的类型==

![image-20250621000051447](_汇编语言期末/image-20250621000051447.png)

![image-20250621000512034](_汇编语言期末/image-20250621000512034.png)![image-20250621000908919](_汇编语言期末/image-20250621000908919.png)

### 第3章

![image-20250623194540717](_汇编语言期末/image-20250623194540717.png)![image-20250623194614701](_汇编语言期末/image-20250623194614701.png)

![image-20250623194654569](_汇编语言期末/image-20250623194654569.png)

![image-20250623194802488](_汇编语言期末/image-20250623194802488.png)

![image-20250623195106132](_汇编语言期末/image-20250623195106132.png)![image-20250623210614078](_汇编语言期末/image-20250623210614078.png)

![image-20250623212244572](_汇编语言期末/image-20250623212244572.png)

![image-20250623220341179](_汇编语言期末/image-20250623220341179.png)

![image-20250623221845638](_汇编语言期末/image-20250623221845638.png)

![image-20250624075907539](_汇编语言期末/image-20250624075907539.png)![image-20250624075916795](_汇编语言期末/image-20250624075916795.png)

![image-20250624081344617](_汇编语言期末/image-20250624081344617.png)



### 第5章 

![image-20250623231730887](_汇编语言期末/image-20250623231730887.png)

### 第6章

![image-20250624173252660](_汇编语言期末/image-20250624173252660.png)

![image-20250624173554833](_汇编语言期末/image-20250624173554833.png)

### 第8章

![image-20250624090029964](_汇编语言期末/image-20250624090029964.png)![image-20250624090046228](_汇编语言期末/image-20250624090046228.png)

![image-20250624100549064](_汇编语言期末/image-20250624100549064.png)





### 第11章 

![image-20250623225151980](_汇编语言期末/image-20250623225151980.png)

### 分支

这个是if语句![image-20250624092950453](_汇编语言期末/image-20250624092950453.png)

![image-20250624092747039](_汇编语言期末/image-20250624092747039.png)

这个是if else，这个跟高级语言不一样的是并不是那个跳转语句是if和else而是下面的那个句子，比如下面那个if是判断D1=1，那么上面的跳转语句就应该是反的，就是！=1，也就是jz

## 课后习题

### 第1章

#### 1.9 IA-32处理器有那三类基本段，各有什么作用？

1. 代码段：存放程序的可执行代码（处理器指令）
2. 数据段：存放程序所用的数据，例如全局变量
3. 堆栈段：程序需要的特殊区域，存放返回地址，临时变量等。

![image-20250624134351603](_汇编语言期末/image-20250624134351603.png)

#### 1.13 汇编语言语句有哪两种，每种语句由哪4部分组成？

![image-20250624133342708](_汇编语言期末/image-20250624133342708.png)

![image-20250624134403908](_汇编语言期末/image-20250624134403908.png)

#### 1.15 在MASM汇编语言中，下面哪些是程序员可以使用的自定义标识符？

![image-20250624134543589](_汇编语言期末/image-20250624134543589.png)

### 1.16 汇编语言程序的开发有哪4个步骤，分别利用什么程序完成，产生什么输出文件？（P29）

编辑，编译（汇编），连接，调试

![image-20250624134047365](_汇编语言期末/image-20250624134047365.png)

![image-20250624134423376](_汇编语言期末/image-20250624134423376.png)

### 第2章

#### 2.10 设置一个数据段，按照如下要求定义变量或符号常量

![image-20250624134915738](_汇编语言期末/image-20250624134915738.png)

![image-20250624135238119](_汇编语言期末/image-20250624135238119.png)

#### 2.15 指令的执行结果

每次+1 加的是一个字节，也就是一个8位byte

![image-20250624135719694](_汇编语言期末/image-20250624135719694.png)

![image-20250624135819392](_汇编语言期末/image-20250624135819392.png)

#### 2.17  说明下列指令中源操作数的寻址方式

![image-20250624140021458](_汇编语言期末/image-20250624140021458.png)

![image-20250624140030710](_汇编语言期末/image-20250624140030710.png)

### 第3章 

#### 3.4 MOV指令支持多种操作数组合，请给每种组合举一个实例

![image-20250624140615960](_汇编语言期末/image-20250624140615960.png)

![image-20250624140819688](_汇编语言期末/image-20250624140819688.png)

#### 3.6 使用MOV指令实现交换指令"XCHG EBX，[EDI]"的功能。

![image-20250624140940658](_汇编语言期末/image-20250624140940658.png)

#### 3.11 分别执行如下程序片段，说明每条指令的执行结果。

![1ec8588def1d489c7d0010b7e226c3e](_汇编语言期末/1ec8588def1d489c7d0010b7e226c3e.jpg)

#### 3.14 请分别用一条汇编语言指令完成如下功能

![image-20250624141828113](_汇编语言期末/image-20250624141828113.png)

![image-20250624142032712](_汇编语言期末/image-20250624142032712.png)

#### 3.16 分别执行如下程序片段，说明每条指令的执行结果

![efe357357df5f392688a6ea16cb6a0c](_汇编语言期末/efe357357df5f392688a6ea16cb6a0c.jpg)

#### 3.21 用一个乘法指令实现上述功能

![cd29e8d95f35044a683cff2faa8f27c](_汇编语言期末/cd29e8d95f35044a683cff2faa8f27c.jpg)

#### 3.22 请使用移位和加减法指令编写一个程序片段计算 EAX * 21，假设乘积不超过32位。

### 第4章 

#### 4.4 用汇编语言编写实现C++语句

![image-20250624143539695](_汇编语言期末/image-20250624143539695.png)

![image-20250624144934328](_汇编语言期末/image-20250624144934328.png)

#### 4.7 输入数组下标，输出其地址和值

![image-20250624145249053](_汇编语言期末/image-20250624145249053.png)

![image-20250624145254878](_汇编语言期末/image-20250624145254878.png)

#### 4.15 编程实现CDQ功能

![image-20250624145407236](_汇编语言期末/image-20250624145407236.png)

![image-20250624145619977](_汇编语言期末/image-20250624145619977.png)

#### 4.17 编写一个程序

### 第5章

#### 5.7 在键盘上按下一个键，将其返回的ASCII码显示出来。如果按下退格键（对应的ASCII码是08H），则程序退出。请调用书上的HTOASC程序

这个htoasc就是将一个al表达的16进制数转换成其ascii值，如0就是‘0’也就是48。

![image-20250624150744793](_汇编语言期末/image-20250624150744793.png)

![image-20250624150758183](_汇编语言期末/image-20250624150758183.png)

#### 5.8 编写一个子程序，以二进制形式显示EAX中32位数据，并设计一个主程序验证。

![image-20250624151811420](_汇编语言期末/image-20250624151811420.png)

![image-20250624152348480](_汇编语言期末/image-20250624152348480.png)

#### 5.11 

![image-20250624153214626](_汇编语言期末/image-20250624153214626.png)

![image-20250624153412937](_汇编语言期末/image-20250624153412937.png)

#### 5.13

 ![image-20250624153627180](_汇编语言期末/image-20250624153627180.png)

![image-20250624154409381](_汇编语言期末/image-20250624154409381.png)

### 第7章 与Visual C++混合编程

#### 7.4 阅读嵌入汇编代码，并且输出运算结果

![image-20250624155359661](_汇编语言期末/image-20250624155359661.png)![image-20250624155405125](_汇编语言期末/image-20250624155405125.png)

#### 7.6 编写汇编语言子程序模块

![image-20250624155456479](_汇编语言期末/image-20250624155456479.png)

